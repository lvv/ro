RO — Range Operators
====================
:compact-option: compact

//include::/tmp/t.ad[]

+++ <small> +++

* Repo: httpx://github.com/lvv/ro[GitHub],  httpx://bitbucket.org/lvv/ro[BitBucket] +
* Requires:  +++ C++11 +++   compiler.  Tested with gcc-4.8 and clang-3.2 +
* License:  httpx://en.wikipedia.org/wiki/Boost_Software_License[Boost Software License]
* Status:  alpha

+++ </small> +++

About
-----

RO is +++C++ +++ headers only library, which provides alternative
interface to STL with some elements of functional programming.

RO operates on _ranges_ which are STL containers, RO-ranges, Tuples, C-arrays or
C-strings. 

RO strives to provide simpler interface and more comprehensible code.
RO, similarly to STL, has zero overhead, and is as efficient
as hand written for-loop.


Introduction and overloaded operators vs functions
--------------------------------------------------

In RO most of operations are provided through overloaded operators.

Some consider that overloaded operators, not having meaningful names and having
multiple overloads are confusing and ambiguous.  I disagree with that.

Below are examples of what is more confusing. 

In this RO code snippet, you can probably figure out what it does without explanation:

---------------------------------------------------------------------------
container << value1 << value2;
---------------------------------------------------------------------------

Yes, this was like applying  two `push_back` (if container was vector-like). That was simple.

With STL it would be not so simple.  And I am not talking about
syntax.  If container is `std::vector` - we will need to use `push_back` .  If
`std::set` - we need `insert`. If `std::map` - we need `operator[]` or
`insert`.  If `std::stack` - that would be `push`.  If `value1` is container too,
you will need `std::copy`. Or `std::slice`. Or plain for-loop.  If container is
a C-string, you will need to close your STL reference and start looking at `man string`. 

Of cause there is logical explanation for STL's non-uniformity.  Operations
performed under the hood are very different for each case.  End result is that
even after many years of using it, I still need STL reference manual handy.

With RO,  above snippet won't change for any container type.
RO library has same interface for STL containers, C-strings, C-arrays and RO-Ranges.

In next example we need to perform simple operation: remove a value from a
`std::vector`. This is why C++ is called "too expert friendly": 

---------------------------------------------------------------------------
vec.erase(stl::remove(vec.begin(), vec.end(), x), vec.end()); 
---------------------------------------------------------------------------

For above you need not only C++ reference, but you will need know erase-remove idiom.
Of cause if container is not `std::vector`, you will have to find out how STL
does erase for your particular container.

Now with RO you won't need 10 parenthesis:

---------------------------------------------------------------------------
vec - x;
---------------------------------------------------------------------------

And again, above expression won't change if we use any container (or range) and if
`x` is  a value, a predicate, iterator or sub-range.

One more. This was used by someone as example of terseness and simplicity of +++C++11+++ :

------------------------
find_if(vec.begin(), vec.end(), [=](int i){ return i > val})
------------------------

With RO (using RO's lambdas):

---------------------------
vec / (_1 > val)
----------------------------

Again, with STL, you will need different algorithm if you are looking for a value
or sub-range. With RO, that would be the same divide op: `v / x`.

Usually we need to find not 1st, but all values. Like so:

--------------------------
vector<int>  result;

auto it=vec.begin(); 
while(it!=vec.end()) {
	find_if(vec.begin(), vec.end(), [=](int i){ return i > val});
	result << *it; 
}
---------------------------

This is rather low level way of doing things. 

RO provides mulch simpler to use - filtered (and lazy) range for this:

-----------------------------------------
vector<int> result = vec | (_1>val);
-----------------------------------------

One of the reasons why RO choose to use operators was because it was designed
to be composable.  Range/functors/RO-lambdas can be combined into complex
expression, where actions usually flow from left to right.  Like classic:

---------------------------------------------------------------------------
container | sort | unique | reverse;
---------------------------------------------------------------------------

If RO used functions instead of operators, this would be much more complex
expression with 4-level deep parenthesis.  Here RO under the hood passes
function pointers from `<algorithm>` to `operator|`.


///////////////////

Map/fold example: find (brute force algorithm) maximum of  `cos(x)` for `8 < x < 9`:

------------------------------------------
double cos_max = range(8, 9, 0.01) * std::cos  || std::max;
------------------------------------------
/////////////////////////

SCC
---

RO was originally part of http://volnitsky.com/project/scc[SCC] (+++ C++ +++
snippet evaluator at shell prompt).  RO does not depends on SCC but we will use
it in examples, so we need to tell about SCC first. 

Without SCC, minimal complete example for above erase code would be:

----------------------------------------------------------------------------
#include <iostream>
#include <string>
using namespace std;

#include <ro/ro.h>
using namespace ro;

int main() {
        vector<int> vec {1,2,3};
        vec - 2; 
        for (int x: vec) {
                cout << x << " ";
        }  
        cout << endl;
}
----------------------------------------------------------------------------

With SCC, equivalent which also shows output, is: 

----------------------------------------------------------------------------
scc 'vector<int> vec{1,2,3};  vec - 2;  vec'
{1, 3}
----------------------------------------------------------------------------

1st line in above is what you type at shell prompt.  2nd line is output.
SCC includes RO and all standard libraries includes; and it sends last
statement-expression, if not terminated by semi-colon, to `std::cout`. 

In examples we will use two SCC's types typedefs: `str` is  `std::string`, and
`vint`  is `std::vector<int>`.  We need these because most examples are
1-liners.  With these we can rewrite above as:

----------------------------------------------------------------------------
scc 'vint{1,2,3} - 2'
{1, 3}
----------------------------------------------------------------------------

RO print operator can print almost any STL objects
directly.  Print operator are `_` and `__`.  Longer one terminates output with `endl`.
Items in print operator (and last expression which will be printed)
are separated by `,` not by `<<`. 

-----------------------------------------------------------------------------
scc  '__ range(3),  endl,  make_tuple("abc",42);'
{0, 1, 2}
⟨abc, 42⟩
-----------------------------------------------------------------------------

Or equivalent:

-----------------------------------------------------------------------------
scc  '__ range(3);  __ make_tuple("abc",42)'
{0, 1, 2}
⟨abc, 42⟩
-----------------------------------------------------------------------------


This is all you need to know about SCC. You can read more, if you wish  on
http://volnitsky.com/project/scc[SCC page].  To be able to run examples you
need to <<_install, install RO>> and
http://volnitsky.com/project/scc/#_install[SCC] 


Ranges and Range Operators
--------------------------

Ranges are generalization of STL containers.
They are RO ranges, STL containers, C-arrays and C-strings.  RO defines
C-strings as zero terminated arrays of `char` (not `signed char` or `unsigned chars`). 

RO have two groups of operators.  First provides simple container management
functions.  This is roughly equivalent to STL container member functions.
You've already seen some ops from this group: 

-----------------------------
rg  << value	 -> rg   //  append value to range
rg1 << rg2	 -> rg1  //  append range2 to range1
                
rg / value	 -> it   //  find()
rg / pred	 -> it   //  find_if()
rg / rg2       	 -> rg3  //  search for sub-range
                
rg - value	 -> rg   //  erase all elements equal to value
rg - pred	 -> rg   //  erase all elements for which pred evaluated to 'true` 
rg - rg2	 -> rg   //  erase subrange 
rg - it		 -> rg   //  erase at iterator
-----------------------------

Full list of 1st group operators can be found in Appendix A.

Second is more complex operations like
fold, reduce, filter and arbitrary transformation of ranges.

RO Ranges
----------

_RO Ranges_ are  ranges that have extended but STL compliant interface.  They
also often do not contain range elements data, they refer to an existing STL
container or generate its elements. 

RO Ranges are:  iterator range, lazy-expression range and numeric range.
Lazy means that its elements are calculated at the moment when range
element is accessed.  Exact type of the range often is not important - these
are types mostly of temporaries.

Numeric range
~~~~~~~~~~~~~

Numeric range is simple numeric sequence generator :

-----------------------------------
// [0,arg1)  open-ended range. Only 1-arg  range() is open-ended.
scc 'range(5)'
{0, 1, 2, 3, 4}

// [arg1,arg2]  closed range
scc 'range(1,5)'
{1, 2, 3, 4, 5}

// same, with explicit step
scc 'range(1,5,1)'
{1, 2, 3, 4, 5}

// floating point; range type is result of type promotion on all range() arguments  
scc 'range(1,5,0.5)'
{1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5}

// negative step
scc 'range(10,0,-1.5)'
{10, 8.5, 7, 5.5, 4, 2.5, 1}

// any arithmetic type
scc 'range('a','z')'
a b c d e f g h i j k l m n o p q r s t u v w x y z

// no need for verbose iota
scc 'vint V = range(5);   V' 
{0, 1, 2, 3, 4}

// is lazy, O(1) storage
scc 'auto ints = range(1,999999999999999999l);  *find(ints.begin(), ints.end(), 5)'
5
-----------------------------------


Iterator range
~~~~~~~~~~~~~~

Iterator range is simple wrapper for pair of iterators.

Assign `42` to elements `2..4` of vector `{1,2,3,4,5,6,7,8,9,10}`:

------------------------------------
scc 'vint V=range(1,10);   range(V/2, V/5) = 42;  V'
{1, 42, 42, 42, 5, 6, 7, 8, 9, 10}
------------------------------------

Expression `range(1,10)` constructs numeric range which initialize `V`.  
Expression `V/2` returns iterator to 1st element with value `2`.  Expression
`range(V/2,V/5)` constructs iterator range from pair of iterators.


Ranges can be assigned to another range even if they have different underlying
containers.  Here is simple lazy-expression range, which shows that it just
a reference to underlying container:

------------------------------------------
scc  'vint V;  auto R=range(V);  R=range(1,10);  R, V'
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
-------------------------------------------------


Operation with C-strings 
~~~~~~~~~~~~~~~~~~~~~~~~

We first assign "abc" to a c-string, then append `"XYZ"` and then remove `"bc"` substring :

-----------------------------------------
scc 'char s[99];  range(s) = "abc";  (range(s) << "XYZ") - "bc"'
aXYZ
------------------------------------------

Note that we can not define overloaded operations if arguments are only POD types (like c-string).
+++C++ +++ do not allow this. This is a reason why we have to wrap `s` with `range()`. For binary
ops, we need to wrap at least one of operands in a class.

Same example, but for `str::string` (without range-wrapping):

-----------------------------------------
scc 'str s("abc");  (s << "XYZ") - "bc"'
aXYZ
------------------------------------------


Operators: Map, Reduce, Filter
----------------------------


Map/Transform
~~~~~~~~~~~~~

Operator `ro::operator* (Range,Functor)` is map/transform operator,
where `Functor` have signature compatible with `return_type(*)(range_elem_type)`.
Examples where `return_type` is the same as `elem_type`:

------------------------------------------
scc 'range("abc") * toupper'
ABC

scc 'vint V{-1,0,1};  V * abs'
{1, 0, 1}
------------------------------------------

In above, `toupper` is defined in `functor.h`,  `abs` is taken from `std::`.

Expression `V * abs` is equivalent to:

----------------------------------------------
std::transform(V.begin(), V.end(), V.begin(), std::abs<int>)'
----------------------------------------------

Example with arbitrary `return_type`:

----------------------------------------------------------------------
scc 'vector<const char*> V{"aa", "bbb"};  V * strlen'
{2, 3}
---------------------------------------------------------------------

Length of longest string:

---------------------------------------------------------------------
scc 'vector<str> V{"aa", "bbb", "c"};  V * size || max'
3
----------------------------------------------------------------------

Functor `size_t ro::size(Range)` is similar to `strlen` but will work  with any Range. 


Fold
~~~~

Operator `ro::operator|| (Range,Functor)` is *fold* operator (aka reduce,
accumulate, compress, catamorphisms, or inject).

------------------------------------------
scc 'vint V{1,2,3};  V || plus<int>()'
6

scc 'vint V{1,2,3};  V || add'  		// add -  similar to std::plus<T>(), but will handle empty ranges too
6

scc 'range(1,3) || mul'				// fuctorial;   mul -  similar to std::multiplies<T>()
6

scc 'vstr V{"aa", "bb", "cc"};  V || add'	// concatenates
aabbcc

scc 'vint V{1,2,3};  V || min'			// uses std::min
1

scc 'vstr V{"aaa", "bb", "cccc"};  V * size ||  min'	// length of shortest string
2
------------------------------------------

Expression  `V || min` is equivalent to:

-------------------------------------------------
std::accumulate (
	std::next(V.begin()),
	V.end(),
	V.front(),
	static_cast<const int& (*)(const int&, const int&)>(std::min<int>)
);
------------------------------------------------


Integrate `sin(x)` from `0` to `pi`
(compare with httpx://www.wolframalpha.com/input/?i=integrate+sin%28x%29+from+0+to+pi[WolframAlpha]):

-------------------------------------------------------
scc 'auto d=0.001;  (range(0,pi,d) * sin || add) * d'
2
-------------------------------------------------------


Fold evaluated as left-fold where init value is
httpx://en.wikipedia.org/wiki/Identity_element[identity element] for performed
operation. 


Pipe
~~~~

Pipe operator have much more freedom on what it can do with range. It can filter out,
resize, reorder and convert to different type. Performed  operation depends on type of right-hand-side object.


Filter:  `range|predicate`
^^^^^^^^^^^^^^^^^^^^^^^^^

Filter are defined with `operators|(Range, Predicate)` and `operator|(Range, elem_type)`. 

Predicate is functor with signature compatible with `bool(*)(elem_type)`. If such is used
with pipe operator, all elements which evaluate to `false` with predicate - are
filtered out:

------------------------------------------
scc 'range("abc-123") | isdigit'
123
-----------------------------------------

Filter and transform:

-----------------------------------------
scc '(range("abc-123, xyz/") | isalnum) * toupper'
ABC123XYZ
------------------------------------------

Hide digits:

---------------------------------------------------------------------
scc "str S=\"John Q Public  (650)1234567\";  S|isdigit='X';  S"
John Q Public  (XXX)XXXXXXX
-----------------------------------------------------------------

Expression `S | isdigit`, produce a filtered range,  where `isdigit` is
predicate for filtering.  This is lazy-evaluated, it does not creates
temporary container and should be as efficient as hand written for-loop.

Filter `operator|(Range, range_elem_type)` selects only elements which are
equal to second argument. 

Count number of  `2` elements, then replace `2` with `42`:

---------------------------------------------------------------------
scc 'vint V{1,2,3,2};   size(V|2)'
2

scc 'vint V{1,2,3,2};  V|2 = 42;  V'
{1, 42, 3, 42}
-----------------------------------------------------------------

Something interesting:

---------------------------------------
scc 'vint V{1,2,3,2};  (V|2 = 42)'
{}
---------------------------------------

Why empty range? Because this is range with all elements in `V` equal to `2`.
But all `2` were replaced.  Underling container `V` is now `{1, 42, 3, 42}`,
and  `{1, 42, 3, 42} | 2` is empty range.


Evaluate:  `range|stl-algorithm`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Simple `operator|(Range, void(*)(It,It)) -> Range` matches STL algorithm which have 2 argument iterators:

-----------------------------------------------------------------
scc 'vint{3,1,2} | sort | reverse'
{3, 2, 1}
-----------------------------------------------------------------


Unlike other operators, it does not return new lazy-expression-range object,
but the same range that was on input, modified in place (and requires mutable
range) by corresponding stl-algorithm. Above example is equivalent to:

-----------------------------------------------------------------
scc 'vint V{3,1,2};  sort(+V,-V);  reverse(+V,-V);  V'
{3, 2, 1}

-----------------------------------------------------------------

Unary `+` and `-` corresponds to members `begin()` and `end()`.

Another signature which can be matched is  `operator|(Range, It(*)(It,It))` -
this can match algorithms like `std::unique`:

-----------------------------------------------------------------
scc 'vint{3,1,2,3} | sort | unique'
{1, 2, 3}
-----------------------------------------------------------------

Which is equivalent to: 

-----------------------------------------------------------------
scc 'vint V{3,1,2,3};  sort(+V,-V);  auto e=unique(+V, -V);  V.erase(e,-V);  V'
{1, 2, 3}
-----------------------------------------------------------------


RO Functors
~~~~~~~~~~~

Functors are function object, lambdas and plain functions. 

///////////////////////////////////
All RO operators are templated. Specifying concrete type for templated
operators is impractical, and its concrete types must be deduced. Unfortunately
+++C++ +++ can not deduce function type if it is overloaded. 
...
///////////////////////////////////

Regrettably not all function, are usable with RO. 

For example RO relies on fact that functor have argument of the same type as
range element type.  But for examples `ctype.h` functions, which work with
c-strings, have not `char` but `int` as parameter and they can be defined as
macros.  And what makes it even worse,  they are randomly injected into default
namespace by +++ LIBSTDC++ +++.  As workaround RO put equivalent functions
with correct signatures into `ro` namespace.

Also, even if we do not use using-directive or using-declaration, +++C++11+++
inject into default namespace old C names.  +++C++11+++ comity made this
compiler defect a standard.  For example: `<string>` includes `<cstdlib>` which
define in default namespace `div`.  So we are forced to use our `div` functor
with `ro::`.

Also compiler have its own peculiarities.  Following compiles with clang, but not with gcc:

-----------------------------------------------------
scc 'map<int,int> M{{1,11}, {2,22}};  M * get\<0>'
{1, 2}
-----------------------------------------------------


RO also defines some generic helper functions:

* `size(range) -> size_t` 
* `empty(range) -> bool`
* `endz(range) -> It` -- like `std::end(StlContainer)`, but will work with C-strings too
* `clear(range) -> void`
* all `ctype` functions reimplemented 
* `add`,`sub`, `mul` and `div` - function object equivalent to `std::plus<T>()`, etc


/////////////
LAMBDA
------

BOOST DOC: 

By default, temporary const copies of the bound arguments are rored in the
lambda functor. This means that the value of a bound argument is fixed at the
time of the creation of the lambda function and remains constant during the
lifetime of the lambda function object. For example:

	int i = 1;
	(_1 = 2, _1 + i)(i);

The comma operator is overloaded to combine lambda expressions into a sequence;
the resulting unary lambda functor first assigns 2 to its argument, then adds
the value of i to it. The value of the expression in the last line is 3, not 4.

Wrapping an argument with ref, or cref, instructs the library to rore the
argument as a reference, or as a reference to const 

-- RO var uses lvalue ref for lvalues and for rvalues rore value in functor (with  move-ctor).
----------------------------------
A general restriction for the actual arguments is that they cannot be non-const rvalues. For example:

int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)

--- ro do not have such limitations

------------
The call constant(' ') creates a nullary lambda functor which rores the
character constant ' ' and returns a reference to it when invoked. The function
constant_ref is similar, except that it rores a constant reference to its
argument.

--- RO constant() always returns obj with  const T&


------------------------
scc 'std::bind(sin,1.0)()'
0.841471

scc 'std::bind(sin,_1)(1.0)'
<compiler error>

/////////////

Simple IO
---------

Bar-print
~~~~~~~~~

Instead of `std::cout` printing, in SCC you can use so called **bar-print**.
Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                  //  cout << x;
__ x;                  //  cout << x << endl;
__ x, y;               //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

On last line `" "` will not be printed if  `x` or `y` are strings.

On exit, SCC also checks if last output was unterminated  with linefead.  If
true, it will add a linefead.  Let say if last statement was `cout << x;`, then SCC
will add `cout << endl;` on exit.


OI - Generic ostream_iterator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Standard library includes `std::ostream_iterator`. Unlike `std::cout` it
accepts only one specific type (specified at construction time) and it is not
pre-defined object.   So to use it with STL algorithms, you need
call its quite verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
to print these.  With `std::ostream_iterator`:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>   (cout, " "));
copy(S.begin(), S.end(), ostream_iterator<string>(cout, " "));
-------------------------------------------------------------------

Include `io.h` defines `oi` object - SCC replacement for `ostream_iterator`,
which can work with any type and is pre-defined.  With `oi`, above example will
be:

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

Same using range operators:

-------------------------------------------------------------------
copy(+V, -V, oi);
copy(+S, -S, oi);
-------------------------------------------------------------------

Also assigning a container to `oi` is equivalent to doing
`std::copy`, so still shorter:

-------------------------------------------------------------------
oi = V;
oi = S;
-------------------------------------------------------------------

STL Containers input / output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any STL container can be also printed without `oi`.  You can just send it to
`std::cout` or bar-print it.

In below example `__ C;` can be replaced with `cout << C;`. Equivalent code and
output is shown in comments:

--------------------------------------------------------------------
vint            C {1,2,3};        __ C;	   //  vector<int> C{1,2,3};
 					   //  cout << "{"; 
					   //  for(auto it=C.begin(); it!=C.end()-1; it++)
					   //       cout << *it << ", ";
					   //  if(!C.empty()) cout << C.back(); 
					   //  cout << "}\n";
					   //  prints: {1, 2, 3}
					
int             C[] {1,2,3};       __ C;   //  {1,2,3} 
array<int,3>    C {1,2,3};         __ C;   //  {1,2,3}
tuple<int,int>  C {1,2};           __ C;   //  ⟨1, 2⟩ 
map<int,int>    C {{1,2},{3,4}};   __ C;   //  {⟨1,2⟩, ⟨3,4⟩} 
vector<vint>	C {{1,2},{3,4}};   __ C;   //  {{1, 2}, {3, 4}}
-------------------------------------------------------------------

Same for input:

----------------------------------------------------------------------
echo 1 2    | scc 'vint            C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1,2⟩
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'set<int>        C;     cin >> C;   C'	//  {1,2}
echo 1 2 3 4| scc 'map<int,int>    C;     cin >> C;   C'	//  {⟨1,2⟩, ⟨3,4⟩}
----------------------------------------------------------------------

//////////////
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1, 2}
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1, 2}
echo 1 2.2  | scc 'pair<int,float> p;     cin >> p;   p'	//  ⟨1,2.2⟩
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1, 2⟩
////////////

If a container have non-zero length, then the corresponding number of elements will be
read.  If container is empty then input will be EOF-terminated.

Object IN
~~~~~~~~~

Pre-defined object `in` can be used as value in expression which is read from
`std::cin`.

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in);	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

WARNING: Object `in` does not check for EOF. Use only in
context where you can ignore or do not expect EOF.

To input a container:

--------------------------------------------------------------------
vint V = in(10);
vint W = in;		// Till EOF.  Note:  we can not use:  vint W(in);
--------------------------------------------------------------------

Here is example of +++ C++ +++ vs SCC input where we need to read a number and than
corresponding number of container elements:

--------------------------------------------------------------------
int N; 
cin >> N;
vector<int> V(N); 
for(int i=0; i<N; i++) 
	cin >> V[i];
--------------------------------------------------------------------

With object `in`:

--------------------------------------------------------------------
vint V = in(in);
--------------------------------------------------------------------


IO.H - Standalone Use
~~~~~~~~~~~~~~~~~~~~~

File `io.h` can be used as standalone, independent include. 

-------------------------------------------
#include <io.h>
int main() {
	__ "hello world";
}
-------------------------------------------

Includes `simple.h`, `cj.h` and `stl.h` can also be used independently.


Install
-------

-----------------------------------------
git clone http://github.com/lvv/ro /PATH/TO/INSTALL/RO/

echo '
	#include <ro/ro.h> 
	using namespace ro;
	int main() {
		return range(10) || add;
	}
' > /tmp/ro-test.cc

# test compile
CXXFLAGS+='-I/PATH/TO/INSTALL/ -std=c++11' make /tmp/ro-test  &&  /tmp/ro-test
---------------------------------------

If you install in includes default-searchable directory (like `/usr/include` or
`/usr/local/include`), you do not need to specify `-I /path/to/install/` compiler option.

For CLANG use following options:

--------------------------------------------------
CXX=clang++
CXXFLAGS+="-D__STRICT_ANSI__  -std=c++0x "
----------------------------------------------------

To be able to run examples you need to http://volnitsky.com/project/scc/#_install[install SCC] too. 

///////////////////////
["graphviz", "include-deps.png"]
---------------------------------------------------------------------
// vim:ft=graphviz

digraph G {
        //rankdir=LR;

        //   MODULES
        {  node [shape=box];   
			"mapped_range.h";
			"predicated_range.h";
			"iterator_range.h"; 
			"numeric_range.h";
		"range.h";
		"lambda.h";
		"io.h";
		"stl.h";
		"regex.h";
	}


        {  rank=same;         
		"mapped_range.h"; 
		"predicated_range.h"; 
		"iterator_range.h"; 
		"numeric_range.h";
	}

        "meta.h"         ->  "stl.h" -> "basic_range.h"                                      ;
					"basic_range.h" ->  "mapped_range.h"            -> "range.h";
                			"basic_range.h"	->  "predicated_range.h"        -> "range.h";
        "meta.h"           			      	->  "iterator_range.h"	        -> "range.h";
        "meta.h"                                        ->  "numeric_range.h"           -> "range.h";

        "meta.h"           ->  "functor.h";
		"stl.h"           ->  "lambda.h";
		"range.h"           ->  "lambda.h";
		"range.h" -> "io.h";

		"regex.h";
		"debug.h";


	"functor.h" -> "ro.h";
	"range.h"   -> "ro.h";
	"stl.h"     -> "ro.h";
	"io.h"      -> "ro.h";
	"regex.h"   -> "ro.h";

}
--------------------------------------------------------------------
///////////////////////

image::include-deps.png

Status 
------

RO was tested with GCC-4.8 and CLANG-3.2.


Appendix A
----------

In table below are 1st group - simple shortcuts for container member functions.
Unlike STL member functions (which often return `void`), they usually return
result of operation (so it can be used in expressions).  In comments shown
semantic, not exact operation which will be performed - these might  be very
different for different type of range.

----------------------------------------------------------------
			//  This is just approximate semantic, not exact impl
+rg			//  rg.begin()
-rg			//  rg.end()
++rg			//  rg.front()
rg++			//  rg.back()
--rg			//  rg.pop_front()
rg--			//  rg.pop_back()

rg << value		//  rg.push_back(value)  or similar in semantic operators
value >> rg		//  rg.push_front(value)
rg >> value		//  value = rg.back(value);   rg.pop_back();
value << rg		//  value = rg.front(value);  rg.pop_front();
rg1 << rg2		//  copy(rg2.begin(), rg2.end(), back_inserter(rg1));
rg1 >> rg2		//  copy(rg1.rbegin(), rg1.rend(), front_inserter(rg2)); 

++pair			//  pair.first
pair++			//  pair.second

++tuple			//  get\<0>(tuple)
tuple++			//  get<tuple_size<tuple<Types...> >::value-1>(tuple)


stack << value		//  stack.push(value)
stack++ 		//  stack.top()
stack-- 		//  stack.pop()
stack >> value		//  value = stack.top(value);  stack.pop()
		
queue++ 		//  queue.back()
++queue 		//  queue.front()
--queue 		//  queue.pop()
queue << value		//  queue.push(value)
value << queue		//  value = queue.front(value);  queue.pop()

rg = rg2 		//  underlying containers can be of different type
rg = value 		//  fill(rg.begin(), rg.end(), value)

// SEARCH

rg / value		// find(+rg, -rg, value)
rg % value		// find(+rg, -rg, value) != -rg
rg / Pred		// find_if(+rg, -rg, pred) 	
rg % Pred		// find_if(+rg, -rg, pred) != -rg
rg / rg			// search(+rg, -rg, +rg, -rg) 


// GENERIC ERASE

rg - value		// erase all elements equal to value
rg - pred		// erase all elements for which pred evaluated to 'true` 
rg - rg2		// erase subrange 
rg - it			// erase at iterator

----------------------------------------------------------------



///////////////////////////////////////////
In course of development several GCC bugs were encountered.
Luckily, GCC team is pretty quick to fix things after you will file a but report.

- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=51989[Bug 51989 (fixed) -- deque iterator, void with templates]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54425[Bug 54425 -- Rvalue/Lvalue overload resolution of templated]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54111[Bug 54111 -- function return type template deduction]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54538[Bug 54538 (fixed) -- (4.8 Regression) Getting assembler messages when compiling]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=53858[Bug 53858 (fixed)  -- (4.8 Regression) template aliases used in template parameters default expression]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54648[Bug 54648 -- constexpr function rejected as non const]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54859[Bug 54859 -- constexpr in template aliase rejected as non-constant]
- http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55694  -- ivalid
 Bug 55766 - temlate alias is not equivalent (const-ness is not recognized)
///////////////////////////////////////////



/////////////////////////////////////////////////
Corresponding CLANG bugs:

- httpx://http://llvm.org/bugs/show_bug.cgi?id=11851[Bug 11851 - constexpr bug ]
- httpx://http://llvm.org/bugs/show_bug.cgi?id=13970[Bug 13970 - constexpr function rejected as non const(dup of 11851)]
/////////////////////////////////////////////////






////////////////

== Refs 

REGEX
	* httpx://www.johndcook.com/cpp_regex.html[Getting started with C++ TR1 * regular expressions]
	* http://www.informit.com/articles/article.aspx?p=2079020[Regular Expressions 101: Regex in +++C++11+++]
	* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
	* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
	* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
	* httpx://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Format]
	* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial[+++C++11 +++ regex tutorial. Part-1 ]/
	* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial-part-2[+++C++11 +++  regex tutorial. Part-2]/

	constexpr (at complie time) --
	http://cpptruths.blogspot.com/2011/07/compile-time-regex-matcher-using.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+CppTruths+%28C%2B%2B+Truths%29&utm_content=Google+Reader
	A Regular Expression Matcher by Rob Pike -- http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
	Writing own regular expression parser -- http://www.codeproject.com/KB/recipes/OwnRegExpressionsParser.aspx
	http://swtch.com/~rsc/regexp/
	PCRE++ http://www.linuxquestions.org/questions/showthread.php?p=4387972#post4387972
MISC
	SETS -- http://docs.python.org/2/library/sets.html#set-objects
	operators overloading -- http://www.reddit.com/r/programming/comments/15ob1l/why_arent_userdefined_operators_more_common/
	Live Programming -- http://liveprogramming.github.com/liveblog/2013/01/13/a-hirory-of-live-programming.html
	http://kotaku.com/5975610/the-exceptional-beauty-of-doom-3s-source-code
	miniformat -- http://www.altdevblogaday.com/2013/04/13/a-fast-type-safe-minimal-string-formatting-library-miniformat/
FP
	TODO  select --  http://paulkeir.wordpress.com/2012/12/03/building-tuple-indices/

	Functional Programming in C++ --- http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
	F# -- ref: op on ranges -- http://msdn.microsoft.com/en-us/library/ee353635.aspx
	Pyhone: Functional Programming with Collections -- http://www.itmaybeahack.com/book/python-2.6/html/p02/p02c10_adv_seq.html
	FP -- http://www.dev.gd/20121224-understanding-map-filter-and-fold.html
	FP -- http://richardminerich.com/2012/07/functional-programming-is-dead-long-live-expression-oriented-programming/
	overview of map in Haskel, F#, Java, Scala -- http://insightfullogic.com/blog/2012/dec/9/are-all-map-functions-same/
	First-class function  -- http://en.wikipedia.org/wiki/First-class_function


SQL/LINQ
	http://en.wikipedia.org/wiki/SQL
	http://en.wikipedia.org/wiki/Language_Integrated_Query

BOOST LAMBDA
	BLL:  int i = 1;  (_1 = 2, _1 + i)(i);    	
	3
	BLL:  int i = 1;  (_1 = 2, _1 + ref(i))(i);	
	4

	RO: scc 'int i = 1;  ((_1 = 2, _1 + i)(i))'	// ?????
	32767
	RO: scc 'int i = 1;  0+((_1 = 2, _1 + i)(i))'
	4


	-------
	int i = 1; int j = 2; 
	(_1 + _2)(i, j); // ok
	(_1 + _2)(1, 2); // BLL - error, RO - ok
	------------------
	The logic(boolean) operators have by the default a short-circuiting way
	of acting in expressions with multiple boolean operations.  This behavior does
	not apply to operators that are overloaded by the programmer. 
	--------------------------------
	BLL and std::bind/function: does not support std::abs:
	scc 'bind(abs,_1)(-1)'	 // error

	RO supports:
	scc 'vint{-1,0,1} * abs'
	{1, 0, 1}



BOOST MULTI_INDEX
	Использование boost::multi_index --- http://blog.alno.name/ru/2008/04/using-boost-multi-index
	About Boost Multi-index Containers --- http://lynxline.com/about-boost-multi-index-containers/
	TR http://library.developer.nokia.com/index.jsp?topic=/S60_5th_Edition_Cpp_Developers_Library/GUID-02F20077-73B5-4A63-85DB-D909E0ADE01C/html/con_multi_index_tutorial_key_extraction.html


RANGES
	http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html

	for random order filter:
		Take arbitrary integer number P that GCD(P, N) == 1 where
		GCD(P, N) is greatest common divisor of P and N (e.g. GCD(70,
		42) == 14, GCD(24, 35) == 1).

		Get sequence K[i] ::= (P * i) mod N + 1, i from 1 to N

		It's proven that sequence K[i] enumerates all numbers between 1
		and N with no repeats (actually K[N + 1] == K[1] but that is
		not a problem because we need only first N numbers).

		If you can efficiently generate such numbers P with uniform
		distribution (e.g. with a good random function) with using
		Euclidean algorithm to calculate GCD in O(log(N)) complexity
		you'll get what you want.

	IO Ranges
		line iterator -- TR http://stackoverflow.com/questions/1567082/how-do-i-iterate-over-cin-line-by-line-in-c/156770
	

	http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html

	random iterator
		Take arbitrary integer number P that GCD(P, N) == 1 where GCD(P, N) is greatest common divisor of P and N (e.g. GCD(70, 42) == 14, GCD(24, 35) == 1).
		Get sequence K[i] ::= (P * i) mod N + 1, i from 1 to N
		It's proven that sequence K[i] enumerates all numbers between 1 and N with no repeats (actually K[N + 1] == K[1] but that is not a problem because we need only first N numbers).
		If you can efficiently generate such numbers P with uniform distribution (e.g. with a good random function) with using Euclidean algorithm to calculate GCD in O(log(N)) complexity you'll get what you want.


MAP
	TRIE
		http://marisa-trie.googlecode.com/svn/trunk/docs/readme.en.html
		http://login2win.blogspot.com/2011/06/c-tries.html

	HASH_MAP
		http://msinilo.pl/blog/?p=170
			fastest -- http://code.google.com/p/rdestl/
			http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/
			http://attractivechaos.wordpress.com/2008/09/12/the-google-hash-table-library/
			http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
			http://svn.python.org/view/python/trunk/Objects/dictnotes.txt?view=markup&pathrev=53782
	http://stackoverflow.com/questions/11614106/is-gcc-stdunordered-map-implementation-slow-if-so-why
	B-Tree -- https://code.google.com/p/cpp-btree/

STL
	map adapter: https://github.com/krig/k11/blob/master/src/tests/iter.cpp
	STXXL: Standard Template Library for Extra Large Data Sets --- http://stxxl.sourceforge.net/
	Thread Safe Template Library -- http://freecode.com/projects/tstl
	C++ Pipelines -- http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3534.html

TABLE 
	http://en.wikipedia.org/wiki/Language_Integrated_Query
	linq -- http://stackoverflow.com/questions/8910045/template-argument-deduction
	http://stackoverflow.com/questions/14633478/c-table-collection-of-heterogenuously-types-columns
	http://en.wikipedia.org/wiki/Join_(SQL)

SIMILAR PROJECTS

	http://yapb-soc.blogspot.com/2012/10/fmap-in-c-part-1.html
	http://www.ibm.com/developerworks/aix/library/au-learningfc/index.html

vim: ft=asciidoc
///////////////////////////////////
// vim:set ft=asciidoc:
